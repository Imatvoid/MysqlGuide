## sql注入

### mybatis#{} ${} 的区别    
**`#{}`预编译可以防止sql注入，因为已经进行过词法分析和语法分析。语句已经固定，能变的只是参数。**

`${}` 一般不建议使用

1. #将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。如：order by #user_id#，如果传入的值是111,那么解析成sql时的值为order by "111", 如果传入的值是id，则解析成的sql为order by "id".

2. $将传入的数据直接显示生成在sql中。如：order by $user_id$，如果传入的值是111,那么解析成sql时的值为order by user_id,  如果传入的值是id，则解析成的sql为order by id.

3. #方式能够很大程度防止sql注入。

4. $方式无法防止Sql注入。

5. $方式一般用于传入数据库对象，例如传入表名.

6. 一般能用#的就别用$.

MyBatis排序时使用order by 动态参数时需要注意，用$而不是#


### 为什么预编译可以防止注入  
sql注入指的是通过特定的输入参数,和sql语法组合，改变了语法原意。这也是解释性语言的缺陷, 混淆语法和参数。   
一个经典的注入是万能密码 

```mysql
select * from tb_usertable where name='"+HEHE+"'and password='1'or'1'='1'
```
#### sql预编译

SQL之所以能被注入，最主要的原因就是它的数据和代码（指令）是混合的。  
C程序为什么从来没听说过注入这种说法，有也是溢出。这是因为C是一种编译型语言,  
你没法在语义上欺骗它，语义解析这步提前做了，都生成二进制了。  
所以攻击C的方式大多是溢出，通过溢出让数据覆盖指令段。

数据库也提供了这种分离数据和代码（指令）的方式，就是SQL预编译。而SQL语句在程序运行前已经进行了预编译，在程序运行时第一次操作数据库之前，SQL语句已经进行语义解析和语法分析，  对应的执行计划也会缓存下来，允许数据库以参数化的形式进行查询，  当运行时动态地把参数传给PreprareStatement时，即使参数里有敏感字符如 or "1=1"也数据库会作为一个参数一个字段的属性值来处理而不会作为一个SQL指令。  

同时，预编译也可以提高执行速度,因为已经缓存在内存中。

https://yq.aliyun.com/articles/53660